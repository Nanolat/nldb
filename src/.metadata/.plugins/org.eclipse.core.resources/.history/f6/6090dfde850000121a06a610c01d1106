// Copyright (c) 2011, François Saint-Jacques
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the disruptor-- nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL FRANÇOIS SAINT-JACQUES BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#if defined(WIN32) || defined(_WIN64)
#include <WinSock2.h>
#include "../thrift/lib/cpp/src/windows/GetTimeOfDay.h"
#else
# include <sys/time.h>
#endif

#include <llcep/lldb.h>

#include <iostream>
#include <stdio.h>

//#define TEST_ITERATIONS (1000L * 1000L * 300)
// Iterations per transaction
#define TEST_ITERATIONS (1L)
// Total transactions 
//#define TEST_TRANSACTIONS (3L)
#define TEST_TRANSACTIONS (100000000L)
lldb_uint64_t * rndNumsA;
lldb_uint64_t * rndNumsB;

#include <boost/random/uniform_int_distribution.hpp>
#include <boost/random/mersenne_twister.hpp>

// set all duplicate values to 0 in the random value array.
// return the number of eleminated duplicate values.
size_t removeDuplicateNumbers(  size_t rnd_count, lldb_uint64_t * rnd_valus )
{
	size_t dup_count = 0;

	// remove duplicates
	for (size_t i = 0; i< TEST_ITERATIONS - 1; i++ )
	{
		for (size_t j = i+1; j< TEST_ITERATIONS; j++ )
		{
			if (rndNumsA[j] == rndNumsA[i])
			{
				rndNumsA[j] = 0;
				dup_count++;
			}

		}
	}
	return dup_count;
}

void generateRandomNumbers()
{
	rndNumsA = new lldb_uint64_t [TEST_ITERATIONS];
	rndNumsB = new lldb_uint64_t [TEST_ITERATIONS];

	boost::random::mt19937 rng;         // produces randomness out of thin air
										// see pseudo-random number generators
	boost::random::uniform_int_distribution<uint64_t> rnd64(1,((uint64_t)1LL)<<63);
										// distribution that maps to 1..6
										// see random number distributions

	for (size_t i = 0; i< TEST_ITERATIONS; i++ )
	{
  	    rndNumsA[i] = rnd64(rng);                   // simulate rolling a die
  	    rndNumsB[i] = rnd64(rng);                   // simulate rolling a die
	}

	size_t dup_count;
	dup_count = removeDuplicateNumbers( TEST_ITERATIONS, rndNumsA);
	printf("The number of duplicates removed for random value set A : %lud\n", dup_count );

	dup_count = removeDuplicateNumbers( TEST_ITERATIONS, rndNumsB);
	printf("The number of duplicates removed for random value set B : %lud\n", dup_count );
}

const int TEST_DB_ID = 1;
const int VOLATILE_TABLE_ID = 1;
const int PERSISTENT_TABLE_ID = 2;
const int REPLICATION_PORT = 9090;

typedef lldb_uint64_t tbl_key ;
typedef struct tbl_value{
//	char data_message[128];
	long long data_value[1];
}tbl1_value;

static void fatal_exit(const char* error, lldb_rc_t rc) {
	fprintf(stderr, "[code=%d]%s\n",rc, error);

	exit(-1);
}
static void unexpected_result(const char* error, lldb_rc_t actual_rc, lldb_rc_t expected_rc) {
	fprintf(stderr, "%s [expected=%d, actual=%d]\n",error, expected_rc, actual_rc);
}

static void unexpected_value(const char* error, tbl_key key) {
	fprintf(stderr, "%s [key=%lld]\n",error, key);
}


static void create_tables(lldb_db_t & db)
{
	lldb_rc_t rc;
	rc = lldb_table_create(db, VOLATILE_TABLE_ID, LLDB_TABLE_VOLATILE);
	if (rc) fatal_exit("Failed to create a table with VOLATILE_TABLE_ID", rc);

	rc = lldb_table_create(db, PERSISTENT_TABLE_ID, LLDB_TABLE_PERSISTENT);
//	rc = lldb_table_create(db, PERSISTENT_TABLE_ID, LLDB_TABLE_VOLATILE);
	if (rc) fatal_exit("Failed to create a table with LLDB_TABLE_PERSISTENT", rc);
}

static void drop_tables(lldb_db_t & db)
{
	lldb_rc_t rc;
	rc = lldb_table_drop(db, VOLATILE_TABLE_ID);
	if (rc) fatal_exit("Failed to drop a table with VOLATILE_TABLE_ID", rc);

	rc = lldb_table_drop(db, PERSISTENT_TABLE_ID);
	if (rc) fatal_exit("Failed to drop a table with LLDB_TABLE_PERSISTENT", rc);
}

static inline void make_record_value( lldb_uint64_t rnd_value, const char * data_message, tbl_value * ret_value ) 
{
//	memset( ret_value, 0, sizeof(*ret_value));
//	_snprintf(ret_value->data_message, sizeof(ret_value->data_message), "%s-%lld", data_message, rnd_value);
	ret_value->data_value[0] = rnd_value + 1;
}


static void put_random_records( lldb_tx_t & tx, lldb_table_t & table, size_t rnd_count, lldb_uint64_t * rnd_values, const char * data_message, lldb_rc_t expected_rc )
{
	lldb_rc_t rc;

	// put a random record
	for (size_t i=0; i<rnd_count; i++) {
		lldb_uint64_t rnd = rnd_values[i];

		tbl_key key = rnd;
		tbl_value value;

		make_record_value( rnd, data_message, & value );

		lldb_key_t lldb_key = { &rnd, sizeof(rnd) };
		lldb_value_t lldb_value = { &value, sizeof(value) };

		rc = lldb_table_put( tx, table, lldb_key, lldb_value);
		if (rc != expected_rc)
		{
			 unexpected_result("put : got an unexpected result", rc, expected_rc);
		}
	}
}

static void get_random_records( lldb_tx_t & tx, lldb_table_t & table, size_t rnd_count, lldb_uint64_t * exected_rnd_values, const char * data_message, lldb_rc_t expected_rc )
{
	lldb_rc_t rc;

	// put a random record
	for (size_t i=0; i<rnd_count; i++) {
		lldb_uint64_t rnd = exected_rnd_values[i];

		lldb_key_t lldb_key = { &rnd, sizeof(rnd) };
		lldb_value_t actual_value;

		rc = lldb_table_get( tx, table, lldb_key, & actual_value);
		if (rc != expected_rc)
		{
			 unexpected_result("get : got an unexpected result", rc, expected_rc);
		}

		if ( rc == 0 )
		{
			tbl_value expected_value;
			make_record_value( rnd, data_message, & expected_value );

			assert( sizeof( expected_value ) == actual_value.length );

			if ( memcmp( &expected_value, actual_value.data, actual_value.length ) != 0 )
			{
				unexpected_value("get : got an unexpected value for key : %lld", rnd);
			}
		}
	}
}

static void del_random_records( lldb_tx_t & tx, lldb_table_t & table, size_t rnd_count, lldb_uint64_t * rnd_values, lldb_rc_t expected_rc )
{
	lldb_rc_t rc;

	// put a random record
	for (size_t i=0; i<rnd_count; i++) {
		lldb_uint64_t rnd = rnd_values[i];

		lldb_key_t lldb_key = { &rnd, sizeof(rnd) };

		rc = lldb_table_del( tx, table, lldb_key);
		if (rc != expected_rc)
		{
			 unexpected_result("del : got an unexpected result", rc, expected_rc);
		}
	}
}

int llcep_lldb_master(int arc, char** argv) {
	
	generateRandomNumbers();

	lldb_rc_t rc;
	rc = lldb_init();
	if (rc) fatal_exit("Failed to initialize LLDB system", rc);

	// BUGBUG : The master hangs if it runs in the same db path with a slave which is running. 
	// Fix : Need to show an error message "An instance is already up and running on this db path"
	rc = lldb_db_create( TEST_DB_ID );
	if (rc) fatal_exit("Failed to create LLDB", rc);

	lldb_replication_master_op_t master_op = { "*", REPLICATION_PORT };

	lldb_db_t db;
	rc = lldb_db_open( TEST_DB_ID, & master_op, NULL/*slave*/, &db );
	if (rc) fatal_exit("Failed to open LLDB", rc);

	create_tables( db );

	lldb_table_t vol_table;
	rc = lldb_table_open(db, VOLATILE_TABLE_ID, &vol_table);
	if (rc) fatal_exit("Failed to open table, VOLATILE_TABLE_ID", rc);

	lldb_table_t pers_table;
//	rc = lldb_table_open(db, VOLATILE_TABLE_ID, &pers_table);
	rc = lldb_table_open(db, PERSISTENT_TABLE_ID, &pers_table);
	if (rc) fatal_exit("Failed to open table, PERSISTENT_TABLE_ID", rc);

	lldb_tx_t tx;
	rc = lldb_tx_init( db, &tx );
	if (rc) fatal_exit("Failed to initialize a transaction", rc);

    struct timeval start_time, end_time;
	gettimeofday(&start_time, NULL);

	for (int loop = 0 ; loop < TEST_TRANSACTIONS; loop ++ )
	{
		rc = lldb_tx_begin(tx);
		if (rc) fatal_exit("Failed to begin a transaction", rc);

//		for (int i=0; i<2; i++)
		int i=0;
		{
			lldb_table_t table = (i==0)? vol_table : pers_table;
			lldb_uint64_t * rnd_values = (i==0)? rndNumsA : rndNumsB;

//			del_random_records( tx, table, TEST_ITERATIONS, rnd_values, LLDB_ERROR_KEY_NOT_FOUND);
//			get_random_records( tx, table, TEST_ITERATIONS, rnd_values, "ThankyouSoft", LLDB_ERROR_KEY_NOT_FOUND);
			put_random_records( tx, table, TEST_ITERATIONS, rnd_values, "ThankyouSoft", LLDB_OK);
////			put_random_records( tx, table, TEST_ITERATIONS, rnd_values, "ThankyouSoft", LLDB_ERROR_KEY_ALREADY_EXISTS);
//			get_random_records( tx, table, TEST_ITERATIONS, rnd_values, "ThankyouSoft", LLDB_OK);
//			del_random_records( tx, table, TEST_ITERATIONS, rnd_values, LLDB_OK);
		}

		rc = lldb_tx_commit(tx);
		if (rc) fatal_exit("Failed to commit a transaction", rc);
	}

	rc = lldb_db_wait_for_replication_publishers( db );
	if (rc) fatal_exit("Failed to wait for replication publishers", rc);

	gettimeofday(&end_time, NULL);

    double start, end;
    start = start_time.tv_sec + ((double) start_time.tv_usec / 1000000);
    end = end_time.tv_sec + ((double) end_time.tv_usec / 1000000);

    std::cout.precision(15);
    std::cout << "LLDB performance: ";
    std::cout << (TEST_TRANSACTIONS * 1.0) / (end - start)
              << " transactions/secs" << std::endl;

	rc = lldb_tx_destroy( tx );
	if (rc) fatal_exit("Failed to destroy a transaction", rc);

	printf("Press Enter to start closing/dropping tables, closing DB, dropping DB\n");
	char ch = getchar();

	rc = lldb_table_close(vol_table);
	if (rc) fatal_exit("Failed to close table, VOLATILE_TABLE_ID", rc);

	rc = lldb_table_close(pers_table);
	if (rc) fatal_exit("Failed to close table, VOLATILE_TABLE_ID", rc);

	drop_tables( db );

	rc = lldb_db_close( db );
	if (rc) fatal_exit("Failed to close LLDB", rc);

	rc = lldb_db_drop( TEST_DB_ID );
	if (rc) fatal_exit("Failed to drop LLDB", rc);

	rc = lldb_destroy();
	if (rc) fatal_exit("Failed to finalize LLDB instance", rc);

    return EXIT_SUCCESS;
}

int llcep_lldb_slave(int arc, char** argv) {

	lldb_rc_t rc;
	rc = lldb_init();
	if (rc) fatal_exit("Failed to initialize LLDB system", rc);

	rc = lldb_db_create( TEST_DB_ID );
	if (rc) fatal_exit("Failed to create LLDB", rc);

	lldb_replication_slave_op_t slve_op = { {"localhost", REPLICATION_PORT} };

	lldb_db_t db;
	rc = lldb_db_open( TEST_DB_ID, NULL /*master*/, & slve_op/*slave*/, & db );
	if (rc) fatal_exit("Failed to open LLDB", rc);

	create_tables( db );

	printf("Press Enter to start dropping tables, closing DB, dropping DB\n");
	char ch = getchar();

	drop_tables( db );

	rc = lldb_db_close( db );
	if (rc) fatal_exit("Failed to close LLDB", rc);

	rc = lldb_db_drop( TEST_DB_ID );
	if (rc) fatal_exit("Failed to drop LLDB", rc);

    return EXIT_SUCCESS;
}

